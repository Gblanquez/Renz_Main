{
  "version": 3,
  "sources": ["../../split-type/dist/split-type.js", "dep:split-type"],
  "sourcesContent": ["/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.2.1\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SplitType = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * Shallow merges the properties of an object with the target object. Only\n   * includes properties that exist on the target object. Non-writable properties\n   * on the target object will not be over-written.\n   *\n   * @param {Object} target\n   * @param {Object} object\n   */\n  function extend(target, object) {\n    return Object.getOwnPropertyNames(Object(target)).reduce(function (extended, key) {\n      var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n      var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n      return Object.defineProperty(extended, key, newValue || currentValue);\n    }, {});\n  }\n\n  /**\n   * Parses user supplied settings objects.\n   */\n\n  function parseSettings(settings) {\n    var object = extend(settings);\n\n    if (object.types || object.split) {\n      // Support `split` as an alias for `types`\n      object.types = object.types || object.split;\n    }\n\n    if (object.absolute || object.position) {\n      // Support `position: absolute` as alias for `absolute: true`\n      object.absolute = object.absolute || /absolute/.test(settings.position);\n    }\n\n    return object;\n  }\n\n  /**\n   * Returns true if `value` is a non-null object.\n   * @param {any} value\n   * @return {boolean}\n   */\n  function isObject(value) {\n    return value !== null && typeof value === 'object';\n  }\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   * Original source: Lodash\n   *\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3)\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE)\n   * // => false\n   *\n   * _.isLength(Infinity)\n   * // => false\n   *\n   * _.isLength('3')\n   * // => false\n   */\n\n  function isLength(value) {\n    return typeof value === 'number' && value > -1 && value % 1 === 0;\n  }\n  /**\n   * Checks if `value` is an array-like object\n   * @param {any} value\n   * @return {boolean} true if `value` is array-like`, else `false`\n   * @example\n   * isArrayLike(new Array())\n   * // => true\n   *\n   * isArrayLike(document.querySelectorAll('div'))\n   * // => true\n   *\n   * isArrayLike(document.getElementsByTagName('div'))\n   * // => true\n   *\n   * isArrayLike(() => {})\n   * // => false\n   *\n   * isArrayLike({foo: 'bar'})\n   * // => false\n   *\n   * * isArrayLike(null)\n   * // => false\n   */\n\n\n  function isArrayLike(value) {\n    return isObject(value) && isLength(value.length);\n  }\n\n  /**\n   * Coerces `value` to an `Array`.\n   *\n   * @param {any} value\n   * @return {any[]}\n   * @example\n   * // If `value` is any `Array`, returns original `Array`\n   * let arr = [1, 2]\n   * toArray(arr)\n   * // => arr\n   *\n   * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n   * let nodeList = document.querySelectorAll('div')\n   * toArray(nodeList)\n   * // => HTMLElement[] s\n   *\n   * // If value is falsy, returns empty array\n   * toArray(null)\n   * // => []\n   *\n   * // For any other type of value, its equivalent to `Array.of(value)`\n   * let element = document.createElement('div')\n   * toArray(element)\n   * // => [element]\n   *\n   */\n\n  function toArray(value) {\n    if (Array.isArray(value)) return value;\n    if (value == null) return [];\n    return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n  }\n\n  /**\n   * Returns true if `input` is one of the following:\n   * - `Element`\n   * - `Text`\n   * - `Document`\n   * - `DocumentFragment`\n   */\n\n  function isNode(input) {\n    return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n  }\n\n  /**\n   * Checks if given value is a string\n   *\n   * @param {any} value\n   * @return {boolean} `true` if `value` is a string, else `false`\n   */\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  /**\n   * Flattens nested ArrayLike object (max 2 levels deep)\n   */\n\n  function flatten(obj) {\n    return toArray(obj).reduce(function (result, item) {\n      return result.concat(toArray(item));\n    }, []);\n  }\n\n  /**\n   * Processes target elements for the splitType function. `target` can any\n   * of the following types.\n   * 1. `string` - A css selector\n   * 2. `HTMLElement` - A single element\n   * 3. `ArrayLike<HTMLElement>` - A collection of elements (ie NodeList)\n   * 4. `Array<HTMLElement | ArrayLike<HTMLElement>>` - An array of elements\n   *     and/or collections of elements\n   *\n   * Returns a flat array of HTML elements. If `target` does not contain any\n   * valid elements, returns an empty array.\n   *\n   * @param {any} target\n   * @returns {HTMLElement[]} A flat array HTML elements\n   * @example\n   *\n   * // Single Element\n   * const element = document.createElement('div')\n   * getTargetElements()\n   * // => [element]\n   *\n   * const nodeList = document.querySelectorAll('div')\n   * getTargetElements(nodeList)\n   * // => HTMLElement[] (all elements in `nodeList`)\n   *\n   * const nodeListA = document.querySelectorAll('div')\n   * const nodeListB = document.querySelectorAll('p')\n   * getTargetElements([nodeListA, nodeListB])\n   * // => HTMLElement[] (all elements in `nodeListA` and `nodeListB`)\n   *\n   * // ID selector\n   * getTargetElements('#id')\n   * // => HTMLElement[]\n   *\n   * // Class selector\n   * getTargetElements('.text')\n   * // => HTMLElement[]\n   *\n   * // Non element object will not be returned\n   * getTargetElements({foo: bar})\n   * // => []\n   *\n   */\n\n  function getTargetElements(target) {\n    var elements = target; // If `target` is a selector string...\n\n    if (isString(target)) {\n      if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n        // If `target` is an ID, use `getElementById`\n        elements = document.getElementById(target.trim().slice(1));\n      } else {\n        // Else use `querySelectorAll`\n        elements = document.querySelectorAll(target);\n      }\n    }\n\n    return flatten(elements).filter(isNode);\n  }\n\n  /**\n   * Stores data associated with DOM elements. This is a simplified version of\n   * jQuery's data method.\n   */\n\n  function Data(owner, key, value) {\n    var data = {};\n    var id = null;\n\n    if (isObject(owner)) {\n      id = owner[Data.expando] || (owner[Data.expando] = ++Data.uid);\n      data = Data.cache[id] || (Data.cache[id] = {});\n    } // Get data\n\n\n    if (value === undefined) {\n      if (key === undefined) {\n        return data;\n      }\n\n      return data[key];\n    } // Set data\n    else if (key !== undefined) {\n        data[key] = value;\n        return value;\n      }\n  }\n  Data.expando = \"splitType\".concat(new Date() * 1);\n  Data.cache = {};\n  Data.uid = 0; // Remove all data associated with the given element\n\n  function RemoveData(element) {\n    var id = element && element[Data.expando];\n\n    if (id) {\n      delete element[id];\n      delete Data.cache[id];\n    }\n  }\n\n  /**\n   * Iterates values of an array or array-like object calling the provided\n   * `callback` for each item. Based on `array.forEach`\n   * @param {any} collection\n   * @param {function} callback\n   */\n\n  function forEach(collection, callback) {\n    var arr = toArray(collection);\n\n    for (var len = arr.length, i = 0; i < len; i++) {\n      callback(arr[i], i, arr);\n    }\n  }\n\n  /**\n   * Splits a string into an array of words.\n   *\n   * @param {string} string\n   * @param {string | RegExp} [separator = ' ']\n   * @return {string[]} Array of words\n   */\n  function toWords(string) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n    string = string ? String(string) : '';\n    return string.split(separator);\n  }\n\n  /**\n   * Splits a string into an array of characters\n   *\n   * TODO:\n   * Add support strings that contain unicode characters (ie Emojis and symbols)\n   *\n   * @param {string} string the string to split\n   * @param {string|RegExp} [separator = ''] Pattern used to separate characters\n   * @return {string[]} the array of chars\n   * @example\n   * toChars('foo')\n   * // => ['f', 'o', 'o']\n   *\n   * toChars('foo bar')\n   * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n   *\n   * toChars('f-o-o', /-/)\n   * // => ['f', 'o', 'o']\n   *\n   * toChars()\n   * // => []\n   */\n  function toChars(string) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    string = string == null ? '' : String(string);\n    return string.split(separator);\n  }\n\n  /**\n   * Create an HTML element with the the given attributes\n   *\n   * attributes can include standard HTML attribute, as well as the following\n   * \"special\" properties:\n   *   - children: HTMLElement | ArrayLike<HTMLElement>\n   *   - textContent: string\n   *   - innerHTML: string\n   *\n   * @param {string} name\n   * @param  {Object} [attributes]\n   * @returns {HTMLElement}\n   */\n\n  function createElement(name, attributes) {\n    var element = document.createElement(name);\n\n    if (!attributes) {\n      // When called without the second argument, its just return the result\n      // of `document.createElement`\n      return element;\n    }\n\n    Object.keys(attributes).forEach(function (attribute) {\n      var value = attributes[attribute]; // Ignore attribute if value is `null`\n\n      if (value === null) return; // Handle `textContent` and `innerHTML`\n\n      if (attribute === 'textContent' || attribute === 'innerHTML') {\n        element[attribute] = value;\n      } // Handle `children`\n      else if (attribute === 'children') {\n          forEach(value, function (child) {\n            if (isNode(child)) element.appendChild(child);\n          });\n        } // Handle standard HTML attributes\n        else {\n            element.setAttribute(attribute, String(value).trim());\n          }\n    });\n    return element;\n  }\n\n  /**\n   * Takes a comma separated list of `types` and returns an objet\n   *\n   * @param {string | string[]} value a comma separated list of split types\n   * @return {{lines: boolean, words: boolean, chars: boolean}}\n   */\n\n  function parseTypes(value) {\n    var types = isString(value) || Array.isArray(value) ? String(value) : '';\n    return {\n      lines: /line/i.test(types),\n      words: /word/i.test(types),\n      chars: /(char)|(character)/i.test(types)\n    };\n  }\n\n  /**\n   * Gets the text content of an HTML element.\n   *\n   * Optionally, <br> tags can be replaced with a unique string so they can be\n   * converted back HTML later on.\n   *\n   * @param {HTMLElement} element\n   * @param {string} BR_SYMBOL\n   * @return {string} the text content of the given element\n   */\n  function getTextContent(element, LINE_BREAK_SYMBOL) {\n    var brTag = /<br\\s*\\/?>/g;\n    var textContent = element.textContent;\n\n    if (LINE_BREAK_SYMBOL) {\n      var innerHTML = element.innerHTML;\n      var tempDiv = document.createElement('div');\n      tempDiv.innerHTML = innerHTML.replace(brTag, \" \".concat(LINE_BREAK_SYMBOL, \" \"));\n      textContent = tempDiv.textContent;\n    } // Remove extra white space\n\n\n    return textContent.replace(/\\s+/g, ' ').trim();\n  }\n\n  var defaults = {\n    splitClass: '',\n    lineClass: 'line',\n    wordClass: 'word',\n    charClass: 'char',\n    types: 'lines, words, chars',\n    absolute: false,\n    tagName: 'div'\n  };\n\n  var createFragment = function createFragment() {\n    return document.createDocumentFragment();\n  };\n\n  var createTextNode = function createTextNode(str) {\n    return document.createTextNode(str);\n  };\n  /**\n   * Splits the text content of a single element using the provided settings.\n   * There are three possible split types: lines, words, and characters. Each one\n   * is optional, so text can be split into any combination of the three types.\n   *\n   * @param {HTMLElement} element the target element\n   * @param {Object} settings\n   * @return {{\n   *   lines: HTMLElement[],\n   *   words: HTMLElement[],\n   *   chars: HTMLElement[]\n   * }}\n   */\n\n\n  function splitSingleElement(element, settings) {\n    settings = extend(defaults, settings); // The split types\n\n    var types = parseTypes(settings.types); // the tag name for split text nodes\n\n    var TAG_NAME = settings.tagName; // A unique string to temporarily replace <br> tags\n\n    var BR_SYMBOL = \"B\".concat(new Date() * 1, \"R\"); // (boolean) true if position is set to absolute\n\n    var isAbsolute = settings.position === 'absolute' || settings.absolute; // The array of wrapped line elements\n\n    var lines = []; // The array of wrapped words elements\n\n    var words = []; // The array of wrapped character elements\n\n    var chars = []; // The plain text content of the target element\n\n    var splitText;\n    /**------------------------------------------------\n     ** SPLIT TEXT INTO WORDS AND CHARACTERS\n     **-----------------------------------------------*/\n    // `splitText` is a wrapper to hold the HTML structure\n\n    splitText = types.lines ? createElement('div') : createFragment(); // Get the element's text content.\n\n    var TEXT_CONTENT = getTextContent(element, BR_SYMBOL); // Create an array of wrapped word elements.\n\n    words = toWords(TEXT_CONTENT).reduce(function (result, WORD, idx, arr) {\n      // Let `wordElement` be the wrapped element for the current word\n      var wordElement;\n      var characterElementsForCurrentWord; // If the current word is a symbol representing a `<br>` tag,\n      // append a `<br>` tag to splitText and continue to the next word\n\n      if (WORD === BR_SYMBOL) {\n        splitText.appendChild(createElement('br'));\n        return null;\n      } // If splitting text into characters...\n\n\n      if (types.chars) {\n        // Iterate through the characters in the current word\n        // TODO: support emojis in text\n        characterElementsForCurrentWord = toChars(WORD).map(function (CHAR) {\n          return createElement(TAG_NAME, {\n            class: \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n            style: 'display: inline-block;',\n            textContent: CHAR\n          });\n        }); // push the character nodes for this word onto the array of\n        // all character nodes\n\n        chars = chars.concat(characterElementsForCurrentWord);\n      } // END IF;\n\n\n      if (types.words || types.lines) {\n        // | If Splitting Text Into Words...\n        // | Create an element (`wordElement`) to wrap the current word.\n        // | If we are also splitting text into characters, the word element\n        // | will contain the wrapped character nodes for this word. If not,\n        // | it will contain the `WORD`\n        wordElement = createElement(TAG_NAME, {\n          class: \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n          style: \"display: inline-block; position: \".concat(types.words ? 'relative' : 'static'),\n          children: types.chars ? characterElementsForCurrentWord : null,\n          textContent: !types.chars ? WORD : null\n        });\n        splitText.appendChild(wordElement);\n      } else {\n        // | If NOT splitting into words OR lines...\n        // | Append the characters elements directly to splitText.\n        forEach(characterElementsForCurrentWord, function (characterElement) {\n          splitText.appendChild(characterElement);\n        });\n      }\n\n      if (idx !== arr.length - 1) {\n        // Add a space after the word.\n        splitText.appendChild(createTextNode(' '));\n      } // If we not splitting text into words, we return an empty array\n\n\n      return types.words ? result.concat(wordElement) : result;\n    }, []); // 4. Replace the original HTML content of the element with the `splitText`\n\n    element.innerHTML = '';\n    element.appendChild(splitText); // Unless we are splitting text into lines or using\n\n    if (!isAbsolute && !types.lines) {\n      return {\n        chars: chars,\n        words: words,\n        lines: []\n      };\n    }\n    /**------------------------------------------------\n     ** GET STYLES AND POSITIONS\n     **-----------------------------------------------*/\n    // There is no built-in way to detect natural line breaks in text (when a\n    // block of text wraps to fit its container). To split text into lines, we\n    // have to detect line breaks by checking the top offset of words. This is\n    // why text was split into words first. To apply absolute\n    // positioning, its also necessary to record the size and position of every\n    // split node (lines, words, characters).\n    // To consolidate DOM getting/settings, this is all done at the same time,\n    // before actually splitting text into lines, which involves restructuring\n    // the DOM again.\n\n\n    var wordsInEachLine = [];\n    var wordsInCurrentLine = [];\n    var lineHeight;\n    var elementHeight;\n    var elementWidth;\n    var contentBox;\n    var lineOffsetY; // TODO: Is it necessary to store `nodes` in the cache?\n    // nodes is a live HTML collection of the nodes in this element\n\n    var nodes = Data(element, 'nodes', element.getElementsByTagName(TAG_NAME)); // Cache the element's parent and next sibling (for DOM removal).\n\n    var parent = element.parentElement;\n    var nextSibling = element.nextElementSibling; // get the computed style object for the element\n\n    var cs = window.getComputedStyle(element);\n    var align = cs.textAlign; // If using absolute position...\n\n    if (isAbsolute) {\n      // Let contentBox be an object containing the width and offset position of\n      // the element's content box (the area inside padding box). This is needed\n      // (for absolute positioning) to set the width and position of line\n      // elements, which have not been created yet.\n      contentBox = {\n        left: splitText.offsetLeft,\n        top: splitText.offsetTop,\n        width: splitText.offsetWidth\n      }; // Let elementWidth and elementHeight equal the actual width/height of the\n      // element. Also check if the element has inline height or width styles\n      // already set. If it does, cache those values for later.\n\n      elementWidth = element.offsetWidth;\n      elementHeight = element.offsetHeight;\n      Data(element).cssWidth = element.style.width;\n      Data(element).cssHeight = element.style.height;\n    } // Iterate over every split text node\n\n\n    forEach(nodes, function (node) {\n      if (node === splitText) return;\n      var isWord = node.parentElement === splitText;\n      var wordOffsetY; // a. Detect line breaks by checking the top offset of word nodes.\n      //    For each line, create an array (line) containing the words in that\n      //    line.\n\n      if (types.lines && isWord) {\n        // wordOffsetY is the top offset of the current word.\n        wordOffsetY = Data(node, 'top', node.offsetTop); // If wordOffsetY is different than the value of lineOffsetY...\n        // Then this word is the beginning of a new line.\n        // Set lineOffsetY to value of wordOffsetY.\n        // Create a new array (line) to hold the words in this line.\n\n        if (wordOffsetY !== lineOffsetY) {\n          lineOffsetY = wordOffsetY;\n          wordsInEachLine.push(wordsInCurrentLine = []);\n        } // Add the current word node to the line array\n\n\n        wordsInCurrentLine.push(node);\n      } // b. Get the size and position of all split text nodes.\n\n\n      if (isAbsolute) {\n        // The values are stored using the data method\n        // All split nodes have the same height (lineHeight). So its only\n        // retrieved once.\n        // If offset top has already been cached (step 11 a) use the stored value.\n        Data(node).top = wordOffsetY || node.offsetTop;\n        Data(node).left = node.offsetLeft;\n        Data(node).width = node.offsetWidth;\n        Data(node).height = lineHeight || (lineHeight = node.offsetHeight);\n      }\n    }); // END LOOP\n    // Remove the element from the DOM\n\n    if (parent) {\n      parent.removeChild(element);\n    }\n    /**------------------------------------------------\n     ** SPLIT LINES\n     **-----------------------------------------------*/\n\n\n    if (types.lines) {\n      // Let splitText be a new document createFragment to hold the HTML\n      // structure.\n      splitText = createFragment(); // Iterate over lines of text (see 11 b)\n      // Let `line` be the array of words in the current line.\n      // Return an array of the wrapped line elements (lineElements)\n\n      lines = wordsInEachLine.map(function (wordsInThisLine) {\n        // Create an element to wrap the current line.\n        var lineElement = createElement(TAG_NAME, {\n          class: \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n          style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n        }); // Append the `lineElement` to `SplitText`\n\n        splitText.appendChild(lineElement); // Store size/position values for the line element.\n\n        if (isAbsolute) {\n          Data(lineElement).type = 'line'; // the offset top of the first word in the line\n\n          Data(lineElement).top = Data(wordsInThisLine[0]).top;\n          Data(lineElement).height = lineHeight;\n        } // Iterate over the word elements in the current line.\n\n\n        forEach(wordsInThisLine, function (wordElement, idx, arr) {\n          if (types.words) {\n            // | If we are splitting text into words,\n            // | just append each wordElement to the lineElement.\n            lineElement.appendChild(wordElement);\n          } else if (types.chars) {\n            // | If splitting text into characters but not words...\n            // | Append the character elements directly to the line element\n            forEach(wordElement.children, function (charNode) {\n              lineElement.appendChild(charNode);\n            });\n          } else {\n            // | If NOT splitting into words OR characters...\n            // | append the plain text content of the word to the line element\n            lineElement.appendChild(createTextNode(wordElement.textContent));\n          } // Add a space after the word\n\n\n          if (idx !== arr.length - 1) {\n            lineElement.appendChild(createTextNode(' '));\n          }\n        }); // END LOOP\n\n        return lineElement;\n      }); // END LOOP\n      // 10. Insert the new splitText\n\n      element.replaceChild(splitText, element.firstChild);\n    }\n    /**------------------------------------------------\n     **  SET ABSOLUTE POSITION\n     **-----------------------------------------------*/\n    // Apply absolute positioning to all split text elements (lines, words, and\n    // characters). The size and relative position of split nodes has already\n    // been recorded. Now we use those values to set each element to absolute\n    // position. However, positions were logged before text was split into lines\n    // (step 13 - 15). So some values need to be recalculated to account for the\n    // modified DOM structure.\n\n\n    if (isAbsolute) {\n      // Set the width/height of the parent element, so it does not collapse\n      // when its child nodes are set to absolute position.\n      element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n      element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all split nodes.\n\n      forEach(nodes, function (node) {\n        var isLineNode = Data(node).type === 'line';\n        var isChildOfLineNode = !isLineNode && Data(node.parentElement).type === 'line'; // Set the top position of the current node.\n        // -> If its a line node, we use the top offset of its first child\n        // -> If its the child of line node, then its top offset is zero\n\n        node.style.top = \"\".concat(isChildOfLineNode ? 0 : Data(node).top, \"px\"); // Set the left position of the current node.\n        // -> If its a line node, this this is equal to the left offset of\n        //    contentBox.\n        // -> If its the child of a line node, the cached valued must be\n        //    recalculated so its relative to the line node (which didn't\n        //    exist when value was initially checked). NOTE: the value is\n        //    recalculated without querying the DOM again\n\n        node.style.left = isLineNode ? \"\".concat(contentBox.left, \"px\") : \"\".concat(Data(node).left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n\n        node.style.height = \"\".concat(Data(node).height, \"px\"); //  Set the width of the current node.\n        //  If its a line element, width is equal to the width of the contentBox.\n\n        node.style.width = isLineNode ? \"\".concat(contentBox.width, \"px\") : \"\".concat(Data(node).width, \"px\"); // Finally, set the node's position to absolute.\n\n        node.style.position = 'absolute';\n      });\n    } // end if;\n    // 14. Re-attach the element to the DOM\n\n\n    if (parent) {\n      if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n    }\n\n    return {\n      lines: lines,\n      words: types.words ? words : [],\n      chars: chars\n    };\n  }\n\n  var _defaults = extend(defaults, {});\n\n  var SplitType = /*#__PURE__*/function () {\n    _createClass(SplitType, null, [{\n      key: \"defaults\",\n\n      /**\n       * The default settings for all splitType instances\n       */\n      get: function get() {\n        return _defaults;\n      }\n      /**\n       * Sets the default settings for all SplitType instances.\n       *\n       * Setting `SplitType.defaults` to an object will merge that object with the\n       * existing defaults.\n       *\n       * @param {Object} settings an object containing the settings to override\n       *\n       * @example\n       * SplitType.defaults = { \"position\": \"absolute\" }\n       */\n      ,\n      set: function set(options) {\n        _defaults = extend(_defaults, parseSettings(options));\n      }\n      /**\n       * Creates a new `SplitType` instance\n       *\n       * @param {any} target The target elements to split. can be one of:\n       *  - {string} A css selector\n       *  - {HTMLElement} A single element\n       *  - {ArrayLike<HTMLElement>} A collection of elements\n       *  - {Array<HTMLElement | ArrayLike<HTMLElement>>} A nested array of elements\n       * @param {Object} [options] Settings for the SplitType instance\n       */\n\n    }]);\n\n    function SplitType(target, options) {\n      _classCallCheck(this, SplitType);\n\n      this.isSplit = false;\n      this.settings = extend(_defaults, parseSettings(options));\n      this.elements = getTargetElements(target) || [];\n\n      if (this.elements.length) {\n        // Store the original HTML content of each target element\n        this.originals = this.elements.map(function (element) {\n          return Data(element, 'html', Data(element).html || element.innerHTML);\n        });\n\n        if (this.settings.types) {\n          // Initiate the split operation.\n          this.split();\n        }\n      }\n    }\n    /**\n     * Splits the text in all target elements. This method is called\n     * automatically when a new SplitType instance is created. It can also be\n     * called manually to re-split text with new options.\n     * @param {Object} options\n     * @public\n     */\n\n\n    _createClass(SplitType, [{\n      key: \"split\",\n      value: function split(options) {\n        var _this = this;\n\n        // If any of the target elements have already been split,\n        // revert them back to their original content before splitting them.\n        this.revert(); // Create arrays to hold the split lines, words, and characters\n\n        this.lines = [];\n        this.words = [];\n        this.chars = []; // cache vertical scroll position before splitting\n\n        var scrollPos = [window.pageXoffset, window.pageYoffset]; // If new options were passed into the `split()` method, update settings\n\n        if (options !== undefined) {\n          this.settings = extend(this.settings, parseSettings(options));\n        } // Split text in each target element\n\n\n        this.elements.forEach(function (element) {\n          // Add the split text nodes from this element to the arrays of all split\n          // text nodes for this instance.\n          var _split2 = splitSingleElement(element, _this.settings),\n              lines = _split2.lines,\n              words = _split2.words,\n              chars = _split2.chars;\n\n          _this.lines = _this.lines.concat(lines);\n          _this.words = _this.words.concat(words);\n          _this.chars = _this.chars.concat(chars);\n          Data(element).isSplit = true;\n        }); // Set isSplit to true for the SplitType instance\n\n        this.isSplit = true; // Set scroll position to cached value.\n\n        window.scrollTo(scrollPos[0], scrollPos[1]); // Clear data Cache\n\n        this.elements.forEach(function (element) {\n          var nodes = Data(element).nodes || [];\n          toArray(nodes).forEach(RemoveData);\n        });\n      }\n      /**\n       * Reverts target element(s) back to their original html content\n       * @public\n       */\n\n    }, {\n      key: \"revert\",\n      value: function revert() {\n        var _this2 = this;\n\n        // Delete the arrays of split text elements\n        if (this.isSplit) {\n          this.lines = null;\n          this.words = null;\n          this.chars = null;\n        } // Remove split text from target elements and restore original content\n\n\n        this.elements.forEach(function (element) {\n          if (Data(element).isSplit && Data(element).html) {\n            element.innerHTML = Data(element).html;\n            element.style.height = Data(element).cssHeight || '';\n            element.style.width = Data(element).cssWidth || '';\n            _this2.isSplit = false;\n          }\n        });\n      }\n    }]);\n\n    return SplitType;\n  }();\n\n  return SplitType;\n\n})));\n", "export default require(\"./node_modules/split-type/dist/split-type.js\");"],
  "mappings": "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",
  "names": ["createFragment", "createTextNode", "SplitType"]
}
